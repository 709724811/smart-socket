            ------
			Quickly传输层
            ------
            Seer
            ------
             YYYY-MM-DD

Quickly传输层

  无论是服务端还是客户端的传输层,都是一个独立的服务，两者都需要实现接口<<<ChannelService>>>，并且该接口已经继承了<<<Runnable>>>，后续可非常方便的将其实现类作为一个线程运行。\
  需要注意的是传输层服务作为数据交互的媒介，其本身是有状态的。且仅能在其处于<<<RUNNING>>>状态才可执行数据收发，在<<<ChannelServiceStatus>>>中已枚举了Server/Client的传输层实现所具备的各个状态。
     
      [1.INIT] 初始状态,刚创建了一个Client/Server服务对象时所处的状态
      
      [2.STARTING] 启动中,执行了<<<start>>>方法,且还处于启动过程中
      
      [3.RUNNING] 运行中,已完成启动并正常提供数据传输服务
      
      [4.STOPPING] 停止中,触发了<<<shutdown>>>且还处于关闭过程中
      
      [5.STOPPED] 已停止,服务已完成关闭操作
      
      [6.ABNORMAL] 异常,在上述各项运行阶段中出现的不可预知的状况
      
=======================================================================

* 

** 传输层服务结构图

[images/channelservice.png] 传输层  

=======================================================================

** AbstractChannelService

 从接口图可知<<<AbstractChannelService>>>实现了接口<<<ChannelService>>>，但是它只是具体服务类别的基础，仅定义传输服务的流程，具体细节还需要由其子类(例如:NioQuickClient、NioQuickServer)实现。
 
*** AbstractChannelService初始化

 <<<AbstractChannelService>>>在构造方法中进行初始化，除了定义参数，还包括初始化消息处理器<<<config.getProcessor().init(config)>>>。消息处理器属于应用层，它与传输层中间还隔了一个协议层。传输层从网络中读取到的数据流都是经协议层进行解码并形成特定的消息实体，再传递至消息处理器进行业务处理的。反之也是消息处理器将需要发送的消息实体经协议层编码转换成数据流，再由传输层发送至网络对端。<<关于消息处理器会有专门的讲解，此处不再累赘>>。
 
+------------------------------------------+
public AbstractChannelService(final QuicklyConfig config) {
	this.config = config;
	READ_LOOP_TIMES = config.getReadLoopTimes();
	WRITE_LOOP_TIMES = config.getWriteLoopTimes();
	try {
		config.getProcessor().init(config);
	} catch (final Exception e) {
		status = ChannelServiceStatus.Abnormal;
		RunLogger.getLogger().log(Level.SEVERE, "", e);
	}
}
+------------------------------------------+

*** run方法的实现

+------------------------------------------+
public final void run() {
	updateServiceStatus(ChannelServiceStatus.RUNING);
	// 通过检查状态使之一直保持服务状态
	while (ChannelServiceStatus.RUNING == status) {
		try {
			// 此处会阻塞在selector.select()直至某个关注的事件将其唤醒
			while (selector.isOpen() && selector.select() > -1) {
				Iterator<SelectionKey> keyIterator = selector.selectedKeys().iterator();
				// 执行本次已触发待处理的事件
				while (keyIterator.hasNext()) {
					SelectionKey key = keyIterator.next();
					try {
						// 建立新连接,Client触发Connect,Server触发Accept
						if (key.isValid() && (key.isAcceptable() || key.isConnectable())) {
							acceptConnect(key, selector);
						}
						// 输出数据至客户端
						if (key.isValid() && key.isWritable()) {
							writeToChannel(key, selector);
						}
						// 读取客户端数据
						if (key.isValid() && key.isReadable()) {
							readFromChannel(key, selector);
						}
					} catch (Exception e) {
						exceptionInSelectionKey(key, e);
					} finally {
						// 移除已处理的事件
						keyIterator.remove();
					}
				}
			}

			if (!selector.isOpen()) {
				RunLogger.getLogger().log(Level.SEVERE, "Selector is already closed!");
				break;
			}

		} catch (Exception e) {
			exceptionInSelector(e);
		}
	}
	updateServiceStatus(ChannelServiceStatus.STOPPED);
	RunLogger.getLogger().log(Level.SEVERE, "Channel is stop!");
}
+------------------------------------------+

 在<<AbstractChannelService>>中仅实现了<<<run>>>方法,且通过final修饰不允许子类修改该方法。无论是服务端还是客户端，都是遵循<<<run>>>方法中的实现运行的。不过两则的区别仅在<<<AbstractChannelService>>>的以下几个抽象方法中体现:
      
      [1. acceptConnect(SelectionKey key, Selector selector)] 建立新连接,Client触发Connect,Server触发Accept
      
      [2. readFromChannel(SelectionKey key, Selector selector)]  从管道流中读取数据
      
      [3. writeToChannel(SelectionKey key, Selector selector)] 往管道流中输出数据
      
      [4. exceptionInSelectionKey(SelectionKey key, Exception e)] 处理某个已触发且发生了异常的SelectionKey
      
      [5. exceptionInSelector(Exception e)]  处理选择器层面的异常,此时基本上会导致当前的链路不再可用
     
=======================================================================
 
** 服务端传输层(NioQuickServer) 

 	  [1. start(SelectionKey key, Selector selector)] 启动传输层服务

+------------------------------------------+	  
public void start() throws IOException {
	try {
		assertAbnormalStatus();
		updateServiceStatus(ChannelServiceStatus.STARTING);
		server = ServerSocketChannel.open();
		server.configureBlocking(false);
		InetSocketAddress address = null;
		if (StringUtils.isBlank(config.getLocalIp())) {
			address = new InetSocketAddress(config.getPort());
		} else {
			address = new InetSocketAddress(config.getLocalIp(),
					config.getPort());
		}
		server.socket().bind(address);
		selector = Selector.open();
		server.register(selector, SelectionKey.OP_ACCEPT, config);
		serverThread = new Thread(this, "Nio-Server");
		serverThread.start();
	} catch (final IOException e) {
		shutdown();
		throw e;
	}
}
+------------------------------------------+
 * <<步骤一:>> 更新服务状态为STARING 

 * <<步骤二:>> 打开ServerSocketChannel，用于监听客户端的连接，它是所有客户端连接的父管道

 * <<步骤三:>> 设置连接为非阻塞模式并绑定监听端口

 * <<步骤四:>> 创建多路复用器Selector并将ServerSocketChannel注册到Selector上，监听ACCEPT事件

 * <<步骤五:>> 启动监听线程
 	
*
 
 	  [2. acceptConnect(SelectionKey key, Selector selector)] 建立新连接,Client触发Connect,Server触发Accept

+------------------------------------------+
protected void acceptConnect(final SelectionKey key, final Selector selector) throws IOException {
	ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();
	SocketChannel socketChannel = serverChannel.accept();
	socketChannel.configureBlocking(false);
	SelectionKey socketKey = socketChannel.register(selector, SelectionKey.OP_READ);
	NioSession session = null;
	session = new NioSession(socketKey, config);
	socketKey.attach(session);
	socketChannel.finishConnect();
}
+------------------------------------------+

 * <<步骤一:>> Selector监听到有新的客户端接入，处理新的接入请求，完成TCP三次握手，建立物理链路 

 * <<步骤二:>> 设置客户端链路为非阻塞模式

 * <<步骤三:>> 将新接入的客户端连接注册到Selector上，监听读操作，用来读取客户端发送的网络消息

 * <<步骤四:>> 创建当前链路的传输层会话并作为SelectionKey的附加对象保存

 * <<步骤五:>> 完成连接<<<socketChannel.finishConnect()>>>这段代码不可缺少
      
*

      [3. readFromChannel(SelectionKey key, Selector selector)]  从管道流中读取数据
 
+------------------------------------------+
protected void readFromChannel(SelectionKey key, Selector selector) throws IOException {
	SocketChannel socketChannel = (SocketChannel) key.channel();
	NioSession session = (NioSession) key.attachment();
	ByteBuffer buffer = session.getReadBuffer();
	int readSize = 0;
	int loopTimes = READ_LOOP_TIMES;// 轮训次数,以便及时让出资源
	do {
		if (session.getStatus() == SystemStatus.Closing) {
			RunLogger.getLogger().log(Level.SEVERE, "socket即将被关闭");
			readSize = -1;
			break;
		} else {
			session.flushReadBuffer();
		}
	} while ((key.interestOps() & SelectionKey.OP_READ) > 0 && (readSize = socketChannel.read(buffer)) > 0
		&& --loopTimes > 0);// 读取管道中的数据块
	// 达到流末尾则注销读关注
	if (readSize == -1) {
		RunLogger.getLogger().log(Level.SEVERE, "注销客户端[" + socketChannel + "]读关注");
		key.interestOps(key.interestOps() & ~SelectionKey.OP_READ);
	}
}
+------------------------------------------+

 * <<步骤一:>> 从SelectionKey中获取当前通道、传输层Session,并从Session中获取用于存储数据的ByteBuffer对象

 * <<步骤二:>> 判断当前服务状态,如果当前通道正处于关闭中状态，终止数据读取;否则刷新一遍已读取的数据(刷新会触发数据解码操作)

 * <<步骤三:>> 判断当前SelectionKey的状态是否可读，并且是否能够从管道中读取到数据。若能读取到数据则重复步骤二开始的操作，直至读取的轮训次数loopTimes达到0

 * <<步骤四:>> 判断最后一次读取的数据量，若为-1表示当前读管道已被注销，不可再次使用，此时移除当前链路的读关注
  
* 
    
      [4. writeToChannel(SelectionKey key, Selector selector)] 往管道流中输出数据
 
+------------------------------------------+
protected void writeToChannel(SelectionKey key, Selector selector2) throws IOException {
	SocketChannel socketChannel = (SocketChannel) key.channel();
	NioSession session = (NioSession) key.attachment();
	ByteBuffer buffer;
	int loopTimes = WRITE_LOOP_TIMES;// 轮训次数,一遍及时让出资源
	while ((buffer = session.getWriteBuffer()) != null && socketChannel.write(buffer) > 0 && --loopTimes > 0) {
		;
	}
	if (session.getStatus() == SystemStatus.Closing && (buffer = session.getWriteBuffer()) == null) {
		session.close();
	}
}
+------------------------------------------+

 * <<步骤一:>> 从SelectionKey中获取当前通道、传输层Session

 * <<步骤二:>> 重复从Session中获取数据输出至管道，直至Session中的数据输出完毕、输出管道已满、轮训次数loopTimes为0这三者中任意一个条件满足时终止本次写操作

 * <<步骤三:>> 判断当前会话状态是否需要关闭当前会话

*

      [5. exceptionInSelectionKey(SelectionKey key, Exception e)] 处理某个已触发且发生了异常的SelectionKey
 
+------------------------------------------+
protected void exceptionInSelectionKey(SelectionKey key, final Exception e) throws Exception {
	RunLogger.getLogger().log(Level.WARNING, "Close Channel because of Exception", e);
	final Object att = key.attach(null);
	if (att instanceof NioSession) {
		((NioSession) att).close();
	}
	key.channel().close();
	key.cancel();
}
+------------------------------------------+

 * <<步骤一:>> 获取并清空当前SelectionKey中存储的附加对象

 * <<步骤二:>> 如果附加对象中存储的事NioSession类型的会话对象时，关闭它

 * <<步骤三:>> 关闭当前通道并注销SelectionKey
      
*

      [6. exceptionInSelector(Exception e)]  处理选择器层面的异常,此时基本上会导致当前的链路不再可用
  
+------------------------------------------+
protected void exceptionInSelector(Exception e) {
	RunLogger.getLogger().log(Level.WARNING, e.getMessage(), e);
}
+------------------------------------------+

 * <<步骤一:>> 暂时不做任何处理，记录日志而已

*
    
      [7. shutdown]  处理选择器层面的异常,此时基本上会导致当前的链路不再可用
  
+------------------------------------------+
public void shutdown() {
	updateServiceStatus(ChannelServiceStatus.STOPPING);
	config.getProcessor().shutdown();
	try {
		if (selector != null) {
			selector.close();
			selector.wakeup();
		}
	} catch (final IOException e1) {
		e1.printStackTrace();
	}
	try {
		server.close();
	} catch (final IOException e) {
		e.printStackTrace();
	}
}
+------------------------------------------+

 * <<步骤一:>> 更新当前服务状态为STOPPING
 
 * <<步骤二:>> 停止消息处理器

 * <<步骤三:>> 关闭Selector以及ServerSocketChannel服务
 
==================================================

** 客户端传输层(NioQuickClient) 

 	  [1. start(SelectionKey key, Selector selector)] 启动传输层服务

+------------------------------------------+	  
public final void start() {
	try {
		updateServiceStatus(ChannelServiceStatus.STARTING);
		socketChannel = SocketChannel.open();
		selector = Selector.open();
		socketChannel.configureBlocking(false);
		socketChannel.register(selector, SelectionKey.OP_CONNECT);
		socketChannel.connect(new InetSocketAddress(config.getHost(), config.getPort()));
		serverThread = new Thread(this, "QuickClient-" + hashCode());
		serverThread.start();
		socketChannel.socket().setSoTimeout(config.getTimeout());

		if (session == null) {
			synchronized (conenctLock) {
				if (session == null) {
					try {
						conenctLock.wait(config.getTimeout());
					} catch (final InterruptedException e) {
						e.printStackTrace();
					}
				}
			}
		}

	} catch (final IOException e) {
		e.printStackTrace();
	}
}
+------------------------------------------+

 * <<步骤一:>> 更新服务状态为STARING 

 * <<步骤二:>> 创建多路复用器Selector

 * <<步骤二:>> 打开SocketChannel，设置为非阻塞模式，并将当前SocketChannel在Selector上注册OP_CONNECT关注

 * <<步骤三:>> 连接服务器地址、端口；并启动客户端服务线程

 * <<步骤五:>> 阻塞客户端的启动线程，直至与服务器对接成功或发生连接超时
 	  
*

 	  [2. acceptConnect(SelectionKey key, Selector selector)] 建立新连接,Client触发Connect,Server触发Accept

+------------------------------------------+
void acceptConnect(SelectionKey key, Selector selector) throws IOException {
	SocketChannel socketChannel = (SocketChannel) key.channel();
	socketChannel.finishConnect();
	key.interestOps(key.interestOps() & ~SelectionKey.OP_CONNECT | SelectionKey.OP_READ);
	session = new NioSession(key, config);
	RunLogger.getLogger().log(Level.SEVERE,
		"success connect to " + socketChannel.socket().getRemoteSocketAddress().toString());
	config.getProcessor().notifyProcess(this);
	synchronized (conenctLock) {
		conenctLock.notifyAll();
	}
}
+------------------------------------------+

 * <<步骤一:>> Selector监听到对接服务器成功，获取链路对象，完成连接 

 * <<步骤二:>> 完成连接后边可以移除OP_CONNECT关注并注册OP_READ关注

 * <<步骤三:>> 创建链路会话

 * <<步骤四:>> 作为客户端，需要主动触发一次消息处理器，并唤醒启动线程

*

      [3. readFromChannel(SelectionKey key, Selector selector)]  从管道流中读取数据
 
+------------------------------------------+
void readFromChannel(SelectionKey key, Selector selector) throws IOException {
	if (key.isReadable()) {
		SocketChannel socketChannel = (SocketChannel) key.channel();
		ByteBuffer buffer = session.getReadBuffer();
		int readSize = 0;
		int loopTimes = READ_LOOP_TIMES;
		do {
			session.flushReadBuffer();
		} while ((key.interestOps() & SelectionKey.OP_READ) > 0 && (readSize = socketChannel.read(buffer)) > 0
			&& --loopTimes > 0);// 读取管道中的数据块
		// 达到流末尾则注销读关注
		if (readSize == -1) {
			RunLogger.getLogger().log(Level.FINEST,
				"the read channel[" + socketChannel + "] has reached end-of-stream");
			key.interestOps(key.interestOps() & ~SelectionKey.OP_READ);
		}
	}
}
+------------------------------------------+

 * <<客户端的数据读取与服务端大致相同>>
      
*

      [4. writeToChannel(SelectionKey key, Selector selector)] 往管道流中输出数据
 
+------------------------------------------+
void writeToChannel(SelectionKey key, Selector selector2) throws IOException {
	SocketChannel socketChannel = (SocketChannel) key.channel();
	ByteBuffer buffer;
	int loopTimes = WRITE_LOOP_TIMES;
	while ((buffer = session.getWriteBuffer()) != null && socketChannel.write(buffer) > 0 && --loopTimes > 0) {
		;
	}
}
+------------------------------------------+

 * <<客户端的数据输出与服务端大致相同>>

*

      [5. exceptionInSelectionKey(SelectionKey key, Exception e)] 处理某个已触发且发生了异常的SelectionKey
 
+------------------------------------------+
void exceptionInSelectionKey(final SelectionKey key, final Exception e) throws Exception {
	throw e;
}
+------------------------------------------+

 * <<客户端在处理SelectionKey事件是发生异常一律抛出>>
      
*

      [6. exceptionInSelector(Exception e)]  处理选择器层面的异常,此时基本上会导致当前的链路不再可用
  
+------------------------------------------+
void exceptionInSelector(final Exception e) {
	if (ChannelServiceStatus.RUNING == status && config.isAutoRecover()) {
		restart();
	} else {
		shutdown();
	}
}
+------------------------------------------+

 * <<客户端Selector发生发生异常时是致命的，只能关闭当前服务或根据环境配置选择重启>> 
    
*
 
      [7. shutdown]  处理选择器层面的异常,此时基本上会导致当前的链路不再可用
  
+------------------------------------------+
public final void shutdown() {
	updateServiceStatus(ChannelServiceStatus.STOPPING);
	config.getProcessor().shutdown();
	try {
		selector.close();
		selector.wakeup();
	} catch (final IOException e) {
		RunLogger.getLogger().log(Level.WARNING, e.getMessage(), e);
	}
	try {
		socketChannel.close();
	} catch (final IOException e) {
		RunLogger.getLogger().log(Level.WARNING, e.getMessage(), e);
	}
}
+------------------------------------------+

 * <<步骤一:>> 更新当前服务状态为STOPPING
 
 * <<步骤二:>> 停止消息处理器

 * <<步骤三:>> 关闭Selector以及socketChannel服务
 
==================================================

 